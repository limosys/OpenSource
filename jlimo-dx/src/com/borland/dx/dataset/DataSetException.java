//--------------------------------------------------------------------------------------------------
// $Header: /usr/local/cvsrepository/JDataStore/JDS/src/java/com/borland/dx/dataset/DataSetException.java,v 7.4.2.2 2005/01/03 17:02:20 sshaughn Exp $
// Copyright (c) 1996-2002 Borland Software Corporation. All Rights Reserved.
//--------------------------------------------------------------------------------------------------

package com.borland.dx.dataset;

import com.borland.dx.text.InvalidFormatException;
import com.borland.jb.util.Trace;
import com.borland.jb.util.ExceptionChain;
import com.borland.jb.util.EventMulticaster;
import com.borland.jb.util.ChainedException;
import com.borland.jb.util.DiagnosticJLimo;

import java.io.IOException;
import java.lang.ClassNotFoundException;
import java.sql.SQLException;


/**
 * A base Exception class used often throughout the dataset package.
The <CODE>DataSetException</CODE> class extends the <CODE>java.lang.Exception</CODE> class and is used heavily by the <CODE>dataset</CODE> package. It encapsulates common errors that can be generated, and methods necessary to access this error information.


<P>The <CODE>DataSetException</CODE> class can have other types of exceptions chained to them, for example, {@link java.io.IOException java.io.IOException} and {@link java.sql.SQLException java.sql.SQLException} exceptions.
In these cases the <CODE>DataSetException</CODE> has an appropriate message that describes the error from the perspective of the DataExpress level API.

<P>Programmatically, use the <CODE>getExceptionChain()</CODE> to obtain any chained exception.  A chained exception (a singly linked list) can contain non-<CODE>DataSetException</CODE> exceptions that were encountered at a lower level API.

<!-- JDS start - remove next three paragraphs -->

<P>dbSwing components automatically catch <CODE>DataSetExceptions</CODE> at runtime,
passing them to the {@link com.borland.dbswing.DBExceptionHandler DBExceptionHandler} component for processing.  If a dbSwing component performs an operation that causes a <CODE>DataSetException</CODE> to occur, a com.borland.dbswingDBExceptionDialog DBExceptionDialog} appears with a message describing the error.

<P>By default, the <CODE>DBExceptionDialog</CODE> has a "Stack Trace" button that displays the exception stack trace.  If the <CODE>DataSetException</CODE> has
chained exceptions, they can be viewed by pressing <CODE>DBExceptionDialog</CODE>'s
Previous and Next buttons.  Refer to the {@link com.borland.dbswing.DBExceptionDialog DBExceptionDialog} class for
information about customizing its default buttons.

<P>If the exception thrown is a {@link com.borland.dx.dataset.ValidationException ValidationException} (a subclass of <CODE>DataSetException</CODE>), the <CODE>DBExceptionDialog</CODE> displays only if there are no <CODE>StatusEvent</CODE> listeners on the <CODE>DataSet</CODE>, for example, a <CODE>JdbStatusLabel</CODE> or <CODE>JdbNavToolBar</CODE> component.  A <CODE>ValidationException</CODE> is generated by a
constraint violation, for example, a minimum or maximum value outside specified ranges, a data entry that doesn't meet an edit mask
specification, an attempt at updating a read-only column, and so on.  If a <CODE>JdbStatusLabel</CODE> is bound to a <CODE>DataSet</CODE>, it automatically
displays messages resulting from constraint violations.
<!-- JDS end -->
 *
 *
 */

public class DataSetException extends RuntimeException
  implements ChainedException
{
  protected int             errorCode;
  protected ExceptionChain  exceptionChain;

  /*  Error codes are reserved in ranges of 1024.
      Highest current range is TransactionException-> 6*1024
  */
  private static final int BASE = 0*1000;

  /** Undefined error.
  */
  public static final int GENERIC_ERROR                             = BASE+0;

  /** Database or Query property not set.
  */
  public static final int BAD_QUERY_PROPERTIES                      = BASE+1;

  /** Not a SELECT query, can't be parsed.
  */

  public static final int NOT_SELECT_QUERY                          = BASE+2;

  /** Unexpected end of query, can't be parsed.
  */
  public static final int UNEXPECTED_END_OF_QUERY                   = BASE+3;

  /** No matching named query parameter could be found.
  */
  public static final int UNKNOWN_PARAM_NAME                        = BASE+4;
  /** Cannot mix named parameters and '?' parameter markers.
  */
  public static final int MISMATCHED_PARAMETER_FORMAT               = BASE+5;
  /** Mismatch between number of parameters markers in query and number of parmaeters in ReadRow.
  */
  public static final int PARAMETER_COUNT_MISMATCH                  = BASE+6;
  /** Can't determine the table name for query property from metadata or
      from parsing the query property.
  */
  public static final int CANNOT_FIND_TABLE_NAME                      = BASE+7;
  /** Could not find any updatable columns when saving dataset data.
  */
  public static final int NO_UPDATABLE_COLUMNS                      = BASE+8;
  /** DataSet must have Columns before data can be imported.  Temporary
      will support eventually.
  */
  public static final int CANNOT_IMPORT_NULL_DATASET                  = BASE+9;
  /** Cannot find column with given columnName.
  */
  public static final int UNKNOWN_COLUMN_NAME                       = BASE+10;
  /** Atempt to add a column with the same name, but different data type as an existing DataColumn.
  */
  public static final int COLUMN_TYPE_CONFLICT                      = BASE+11;
  /** Column postion is out of range.
  */
  public static final int INVALID_COLUMN_POSITION                   = BASE+12;
  /** Column already bound to a DataSet.  Use (Column)Column.clone() to add this column.
  */
  public static final int COLUMN_ALREADY_BOUND                      = BASE+13;
  /** Cannot change Column Data Type becuase the associated column already has data.
  */
  public static final int CANNOT_CHANGE_COLUMN_DATA_TYPE            = BASE+14;
  /** Cannot set calculated property for columns that already have data.
  */
  public static final int SET_CALCULATED_FAILURE                    = BASE+15;
  /** Unknown Variant data type.
  */
  public static final int UNRECOGNIZED_DATA_TYPE                    = BASE+16;
  /* Cannot load more rows than what is specified by the dataSet maxRow property.
  public static final int TOO_MANY_ROWS                             = BASE+17;
  */
  /** Cannot be saved.  None of its updatable columns have a table name.
  */
  public static final int DATASET_HAS_NO_TABLES                     = BASE+18;
  /** Column is in the DataSet, but was excluded from the row.
  */
  public static final int COLUMN_NOT_IN_ROW                         = BASE+19;
  /** List of columns is null or empty.
  */
  public static final int EMPTY_COLUMN_NAMES                        = BASE+20;
  /** Operation cannot be completed.  DataSet has no non-blob columns.
  */

  public static final int NO_NON_BLOB_COLUMNS                       = BASE+21;
  /** Driver does not support this (or any higher) transaction isolation level.
  */
  public static final int TRANSACTION_ISOLATION_LEVEL_NOT_SUPPORTED = BASE+22;
  /** Partial search option can only be used when last column searched on is of String type".
  */
  public static final int PARTIAL_SEARCH_FOR_STRING                 = BASE+23;
  /** Must specify one of First, Last, Next, Prior Locate for locate operations.
  */
  public static final int NEED_LOCATE_START_OPTION                  = BASE+24;
  /* Query has not been executed yet
  public static final int QUERY_NOT_EXECUTED                        = BASE+25;
  */

  /** A query is already in process for this DataSet.
  */
  public static final int QUERY_IN_PROCESS                          = BASE+26;
  /** Please wait.  A Restructure operation on DataSet is in progress.
  */
  public static final int RESTRUCTURE_IN_PROGRESS                   = BASE+27;
  /** Cannot Load DataSet.  DataSet not in load mode
      Unexpected Internal error.
  */
  public static final int ALREADY_LOADING                           = BASE+28;
  /** Cannot Load DataSet.  DataSet not in load mode.
      Unexpected Internal error.
  */
  public static final int LOADING_NOT_STARTED                       = BASE+29;
  /** Cannot modify Column elements in a Scoped DataRow.  Create a new
      scoped DataRow if needed.
  */
  public static final int CANNOT_UPDATE_SCOPED_DATA_ROW             = BASE+30;
  /**
      Attempt to use a DataRow with a DataSet that it is out of synch with.
      DataRows must be created with the DataSet or DataSet they are used with.
      If the structure of a DataSet changes, a new DataRow must be created for it.
  */
  public static final int INCOMPATIBLE_DATA_ROW                     = BASE+31;
  /**
      Attempt load or save a DataSet with an invalid DataSet DataFileFormat property setting.
      See DataFileFormat for valid file format settings.
  */
  public static final int INVALID_DATA_FILE_FORMAT                  = BASE+32;
  /** The number and data type of columns in the DataSet MasterLinkColumns and DetailLinkColumns must match
  */
  public static final int LINK_COLUMNS_ERROR                        = BASE+33;
  /** The SortDescriptor Keys property setting is not compatible with DataSet LinkColumns property.
   *  The Keys property must start with all the columns specified in
   *  the DataSet MasterLinkColumns and DetailColumns properties.
  */
  public static final int MASTER_DETAIL_VIEW_ERROR                  = BASE+34;
  /*<-------->*
   * The detail DataSet was opened directly. In a master/detail relationship, the detail DataSet
   * should be opened implicitly by opening a dataSet on that DataSet.
  */
//! public static final int INVALID_DETAIL_DATASET_OPEN              = BASE+35-recycled below;
  /** Operation failed.  DataSet structurally corrupt.
  */
  public static final int DATASET_CORRUPT                          = BASE+35;
  /** duplicate columnName.
  */
  public static final int DUPLICATE_COLUMN_NAME                     = BASE+36;
  /** DataSet has no unique row identifiers and is not updatable.
  */
  public static final int NOT_UPDATEABLE                            = BASE+37;
  /** More than one row was affected by resolution query (either DELETE or UPDATE query).
  */
  public static final int MULTIPLE_ROWS_AFFECTED                    = BASE+38;
  /** Operation cannot be performed on an open DataSet.  Close the dataSet first.
  */
  public static final int DATASET_OPEN                              = BASE+39;
  /** QueryDataSets that use delayed detail fetching must have a where clause in their query property.
  */
  public static final int NO_WHERE_CLAUSE                           = BASE+40;
  /** Invalid access on an empty DataSet.  If you get this because a master dataSet
      has no rows and the details are being fetched as needed, add persistent columns
      to the detail dataset.  This way the initialization logic can at least determine
      what the columns are for the detail dataSet.
  */
  public static final int DATASET_HAS_NO_ROWS                       = BASE+41;
  /** Operation failed.  DataSet is not open.
  */
  public static final int DATASET_NOT_OPEN                         = BASE+42;
  /* Master navigation error.
  */
  public static final int MASTER_NAVIGATION_ERROR                   = BASE+43;
  /**
    Operation failed.  There is a CalcFieldsListener, but no Columns with CalcType
    property set to CALC.
  */
  public static final int NO_CALC_FIELDS                            = BASE+44;
  /** Cannot open a Database unless the ConnectionDescriptor is set.
  */
  public static final int CONNECTION_DESCRIPTOR_NOT_SET             = BASE+45;
  /** Operation failed.  AggDescriptor has no groupColumns or some groupColumns do not exist in the DataSet.
  */
  public static final int INVALID_AGG_DESCRIPTOR                    = BASE+46;
  /** Chained exception.  To access the lower level exception(s) call
      getExceptionChain().  printStackTrace will display all exceptions in
      the chain.
  */
  public static final int EXCEPTION_CHAIN                           = BASE+47;

  /** Operation failed.  Attempt to sort on non sortable column.  ie BinaryColumn.
  */
  public static final int INVALID_SORT_COLUMN                      = BASE+48;

  /** @updated JB3.0
      Operation failed.  Invalid Column data type for a DataSet Column.  The data type
      is not supported for the StorageDataSet.Store setting in use (MemoryStore or DataStore).
      If the type used is ASSIGNED_NULL, then the cause is probably that a persistent
      Column was added to the DataSet without specifying the Column.DataType property.
      ASSIGNED_NULL is the default property setting when a Column is instantiated.  It
      signifies an uninitialized state.
  */
  public static final int INVALID_COLUMN_TYPE                       = BASE+49;

  /**  Invalid schema file.
  */
  public static final int INVALID_SCHEMA_FILE                       = BASE+50;

  /** No row was affected by resolution query (either DELETE or UPDATE query).
  */
  public static final int NO_ROWS_AFFECTED                          = BASE+51;

  /** DataFile load failed.
  */
  public static final int DATA_FILE_LOAD_FAILED                     = BASE+60;

  /** Failure notifying dependent components of a DataSet reopen.
  */
  public static final int REOPEN_FAILURE                            = BASE+61;

  /** Execution of query failed.
  */
  public static final int QUERY_FAILED                              = BASE+62;

  /** Resolve failed.
  */
  public static final int RESOLVE_FAILED                            = BASE+63;

  /** Resolver object missing.
  */
  public static final int MISSING_RESOLVER                          = BASE+64;

  /** @updated JB3.0
      Detail DataSet being resolved without Master DataSet.  You must use the Database.saveChanges()
      method that has a DataSet[] array as the first parameter.  The array should include the
      detail and its associated master dataset.  Note that the master dataSet in the array must be
      the same DataSet object instance as the one specified in the detail's MasterLink property.
  */
  public static final int MISSING_MASTER_DATASET                    = BASE+65;

  /** SQLException from JDBC API.
  */
  public static final int SQL_ERROR                                 = BASE+66;

  /** Trying to use Database to save changes to a DataSet with
  *   a non-DatabaseResolver derived Resolver.
  */
  public static final int NOT_DATABASE_RESOLVER                     = BASE+67;

  /** Trying to perform an operation that requires a column name
  *   without having specified one.
  */
  public static final int NULL_COLUMN_NAME                          = BASE+68;
  /** DataSet changes are currently being saved.  Retry operation later.

  */
  public static final int RESOLVE_IN_PROGRESS                       = BASE+69;

  /** Use Column.clone() before applying changes.

  */
  public static final int CANNOT_CHANGE_COLUMN                      = BASE+70;

  /** column formatting error for default, min, max values using edit mask or display format.
  */
  public static final int INVALID_FORMAT                            = BASE+71;

  /** @updated JB3.0
      Attempting to read twice from a java.io.InputStream implementaiton that throws an
      exception when InputStream.reset() is called and InputStream.available() returns
      0 bytes.  To correct this, use an InputStream implementation that supports reset().

  */
  public static final int ONEPASS_INPUT_STREAM                      = BASE+72;

  /** DataSet.refetchRow was called with insufficient row id
  */
  public static final int INSUFFICIENT_ROWID                        = BASE+73;

  /** DataSet.refetchRow was called with non existent row id
  */
  public static final int NON_EXISTENT_ROWID                        = BASE+74;

  /** Current DataSet does not refetchRow
  */
  public static final int REFRESHROW_NOT_SUPPORTED                  = BASE+75;


  /** Current DataSet cannot save changes.
  */
  public static final int CANNOT_SAVE_CHANGES                       = BASE+76;

  /** Current DataSet cannot refresh.
  */
  public static final int CANNOT_REFRESH                            = BASE+77;

  /** Execution of query did not return a result set.
  */
  public static final int NO_RESULT_SET                             = BASE+78;

  /** Operation failed due to an IO error
  */
  public static final int IO_ERROR                                  = BASE+79;

  /** Connection could not be closed.
  */
  public static final int CONNECTION_NOT_CLOSED                     = BASE+80;

  /** Occurs when a DataSet requests that a data aware control post field values
      being edited and the field value cannot be posted (most likely due to a validation
      error).
      Unfortunately controls do not currently provide any information on why a post failed.
      In future releases the actual exception that stopped the field post will
      be correctly surfaced.
  */
  public static final int FIELD_POST_ERROR                         = BASE+81;

  /** The driver: {0} could not be loaded.
      This could be a problem with the driver itself, or that the driver is not found on
      the classpath.  In design mode use the IDEClassPath, which is found in the file:
      "\JBuilder\bin\JBuilder.ini".  Exit JBuilder before editing this file.
  */
  public static final int DRIVER_NOT_LOADED_IN_DESIGN              = BASE+82;

  /** The driver: {0} could not be loaded.
      This could be a problem with the driver itself, or that the driver is not found on
      the classpath.  Modify the classpath in the project properties.
  */
  public static final int DRIVER_NOT_LOADED_AT_RUNTIME             = BASE+83;

  /** The URL: {0} could not be found.
      Check for misspellings, and that the right driver is present on the classpath.
  */
  public static final int URL_NOT_FOUND                            = BASE+84;

  /** The URL: {0} could not be found.
      Check for misspellings, and that the right driver is present on the classpath.
      In design mode use the IDEClassPath, which is found in the file:
      "\JBuilder\bin\JBuilder.ini".  Exit JBuilder before editing this file.
  */
  public static final int URL_NOT_FOUND_IN_DESIGN                  = BASE+85;

  /** A column in the DetailLinkColumns should not be included in the parameterRow. Column:  {0}.
  */
  public static final int LINKFIELD_IN_USERPARAMETERS              = BASE+86;

  /** Execution of provider failed.
  */
  public static final int PROVIDER_FAILED                          = BASE+87;

  /** The Provider is already owned by another DataSet.
  */
  public static final int PROVIDER_OWNED                           = BASE+88;

  /** Database or Procedure property not set.
  */
  public static final int BAD_PROCEDURE_PROPERTIES                 = BASE+89;

  /** FetchAsNeeded cannot be set on MasterLinkDescriptor on a DataSetView.
  */
  public static final int NEED_STORAGEDATASET                      = BASE+90;

  /** The database property of the ProcedureDescriptors doesn't match the database we are resolving to.
  */
  public static final int WRONG_DATABASE                           = BASE+91;

  /**
    Operation failed.  There is a CalcAggFieldsListener, but no Columns with CalcType
    property set to AGGREGATE.
  */
  public static final int NO_CALC_AGG_FIELDS                        = BASE+92;

  /**
    The output parameters of this procedure did not match the specification.
  */
  public static final int MISMATCH_PARAM_RESULT                     = BASE+93;

  /** A procedure is already in process for this DataSet.
  */
  public static final int PROCEDURE_IN_PROCESS                      = BASE+94;

  /** A QueryProvider is required.
  */
  public static final int NEED_QUERYPROVIDER                        = BASE+95;

  /** A ProcedureProvider is required.
  */
  public static final int NEED_PROCEDUREPROVIDER                    = BASE+96;

  /** Cannot resolve data, since Database property is not set on Resolver
  */
  public static final int NO_DATABASE_TO_RESOLVE                    = BASE+97;

  /** @since JB2.0
      Cannot find detail with given detailName.
  */
  public static final int UNKNOWN_DETAIL_NAME                       = BASE+98;

  /** @since JB2.0
      Class could not be found during deserialization process.
  */
  public static final int CLASS_NOT_FOUND_ERROR                     = BASE+99;

  /** @since JB2.0
      When an updated row is loaded by StorageDataSet.loadRow(int status),
      the original row must be loaded immediately prior to the updated row.
  */
  public static final int NO_PRIOR_ORIGINAL_ROW                     = BASE+100;

  /** @since JB2.0
      Store property setting is readOnly.
  */
  public static final int READ_ONLY_STORE                           = BASE+101;

  /** @since JB2.0
      Store doesn't implement replaceStoreRow.
      Unexpected internal error.
  */
  public static final int MISSING_REPLACESTOREROW                   = BASE+102;

  /** Execution of procedure failed.
  */
  public static final int PROCEDURE_FAILED                          = BASE+103;

  /**
      @since JB2.0
      storeName property must be one or more characters in length.
  */
  public static final int INVALID_STORE_NAME            = BASE+104;

  /**   @since JB3.0 Delete existing duplicates before creating a new unique sort.
        Use the StorageDataSet.deleteDuplicates() method to delete the duplicates.
  */
  public static final int DELETE_DUPLICATES                          = BASE+105;

  /**   @since JB3.0
        For Columns with a JavaClass property setting.  Checks that all values
        assigned to the column are of the same type as the Column.JavaClass
        property setting.
  */
  public static final int INVALID_CLASS                          = BASE+106;

  /**   @since JB3.0
        Prevents write access if StorageDataSet.CalcListener or StorageDataSet.AggCalcListener
        have not been set on a StorageDataSet component.  Should only occur
        with StorageDataSets that use DataStore for a backing store.  DataStore
        persists the class names of calc listeners.  So if a StorageDataSet
        component opens without specifying a StorageDataSet.CalcListener
        or StorageDataSet.AggCalcListener that were used previously, the StorageDataSet
        is marked readOnly.

        To correct, 1) add the appropriate listeners or 2) call StorageDataSet.recalc().

  */
  public static final int NEEDS_RECALC                          = BASE+107;

  /**
    Cannot open table with class.  It must be opened with a different class
  */
  public static final int INVALID_STORE_CLASS  = BASE+108;

  /**
    Iterator operation not allowed on this row.

    This is typically caused for the following reasons:
    1) write operation attempted while iterating a ReadRow
    2) navigation, insertRow, or post() operation attempted when not iterating a DataSet.

  */
  public static final int INVALID_ITERATOR_USE  = BASE+109;


  /**
      Attempt to specify different primary key when one already exists.
  */
  public static final int DUPLICATE_PRIMARY  = BASE+110;

  /**
      Attempt to specify primary Sort without specifying any sortKey columns.
  */
  public static final int NO_PRIMARY_KEY  = BASE+111;


  /**
      Sort as inserted not supported with descending sort orders.
  */
  public static final int INVALID_SORT_AS_INSERTED  = BASE+112;
  /**
      No keys specified to create index for SortDescriptor
  */
  public static final int INVALID_SORT              = BASE+113;

  /**
  */
  public static final int TOO_MANY_AUTO_INCREMENTS  = BASE+114;

  /**
      This constraint name does not exist
   */
  public static final int INVALID_CONSTRAINT_NAME = BASE+115;

  /**
   *  Creates and throws a DataSetException of type Throwable.
   *
   * @param ex
   */
  public static final void throwExceptionChain(Throwable ex) /*-throws DataSetException-*/ {
    DataSetException.throwException( DataSetException.EXCEPTION_CHAIN,
                                     Res.bundle.getString(ResIndex.ExceptionChain),
                                     ex
                                   );
  }

  /**
   * Creates and throws a DataSetException of type Exception.errorCode.
   * Extracts the corresponding String message for that error using Exception.getMessage().
   *
   * @param errorCode
   * @param ex
   */
  public static final void     throwException(int errorCode, Exception ex)
    /*-throws DataSetException-*/
  {
    throwException(errorCode, ex.getMessage(), ex);
  }

  static final void     throwException(int errorCode, String message, Throwable ex)
    /*-throws DataSetException-*/
  {
    if (ex instanceof DataSetException)
      throw (DataSetException)ex;
    throw new DataSetException(errorCode, message, ex);
  }

  static final void throwException(int errorCode, String message, ExceptionChain chain)
    /*-throws DataSetException-*/
  {
    throw new DataSetException(errorCode, message, chain);
  }

  /**
   * Creates a DataSetException object with properties as specified in its parameters.
   *
   * @param errorCode   The error code generated.
   * @param message     The text message associated with the error code.
   * @param chain       The ExceptionChain object that contains the linked list of generated Exception objects.
   */
  public DataSetException(int errorCode, String message, ExceptionChain chain) {
    this(errorCode, message);
    this.exceptionChain = chain;
  }

  /**
   * Creates a DataSetException object with properties as specified in its parameters.
   *
   * @param errorCode   The error code generated.
   * @param message     The text message associated with the error code.
   * @param ex          The Exception that was generated.
   */
  public DataSetException(int errorCode, String message, Throwable ex) {
    this(errorCode, message);

    exceptionChain = new ExceptionChain();

    exceptionChain.append(ex);
  }

  /**
   * Creates a DataSetException object with the specified message.
   *
   * @param message   The text message associated with the error code.
   */
  public DataSetException(String message) {
    super(message);
    errorCode = GENERIC_ERROR;
  }

  /**
   *  Creates a DataSetException object with a single error.
   *
   * @param errorCode   The error code generated.
   * @param message     The text message associated with the error code.
   */
  public DataSetException(int errorCode, String message) {
    super(message);
    this.errorCode  = errorCode;
  }


  private static final void throwException(int errorCode, String message)
  /*-throws DataSetException-*/
  {
    throw new DataSetException(errorCode, message);
  }

  /**
   *  Overrides the base class implementation of printStackTrace() to display
   *  the error code and any exceptions that may be chained to it.
   *
   * @param out
   */
  public void printStackTrace(java.io.PrintStream out) {
    out.println(Res.bundle.format( ResIndex.ErrorCode, getClass().getName(), Integer.toString(getErrorCode()%1000)));
    if (exceptionChain == null)
      super.printStackTrace(out);
    else {
      super.printStackTrace(out);
      out.println(Res.bundle.getString(ResIndex.ChainedException));
      exceptionChain.printStackTrace(out);
    }
  }

  /**
   *  Overrides the base class implementation of printStackTrace() to display
   *  the error code and any exceptions that may be chained to it.
   *
   * @param s
   */
  public void printStackTrace(java.io.PrintWriter s) {
    s.println(Res.bundle.format( ResIndex.ErrorCode, getClass().getName(), Integer.toString(getErrorCode()%1000)));
    if (exceptionChain == null)
      super.printStackTrace(s);
    else {
      super.printStackTrace(s);
      s.println(Res.bundle.getString(ResIndex.ChainedException));
      exceptionChain.printStackTrace(s);
    }
  }

  /**
   * Prints the stack trace and the ExceptionChain object, if not null.
   */
  public void printStackTrace() {
    printStackTrace(System.err);
  }

  public int getErrorCode() { return errorCode; }

  public ExceptionChain getExceptionChain() {return exceptionChain;}

  /*  previous JavaDoc comments
   *  Add a listener for ExceptionListener dispatches.
   *  If you want to ensure that this static reference is never garbage collected,
   *  Create an object data member and set it to DataSet.class.  Example:
   *    Object classHolder  = DataSet.class;
   */

   /**
    *  Adds a listener for ExceptionListener dispatches.
    *
    * @param listener
    */
  public static final void addExceptionListener(ExceptionListener listener) {
    DataSet.exceptionListeners = EventMulticaster.add(DataSet.exceptionListeners, listener);
  }

   /**
    * Removes a listener for ExceptionListener dispatches.
    *
    * @param listener
    */
  public static final void removeExceptionListener(ExceptionListener listener) {
    DataSet.exceptionListeners = EventMulticaster.remove(DataSet.exceptionListeners, listener);
  }

  /**
      return listeners added by addExceptionListeners.
  */

  /**
   * @return  The listeners added by addExceptionListeners.
   */
  public static final EventMulticaster getExceptionListeners() {
    return DataSet.exceptionListeners;
  }

  /**
   * Creates and throws a DataSetException of BAD_QUERY_PROPERTIES when one
   * or more properties of the QueryDescriptor are invalid.
   */
  public static final void badQueryProperties() /*-throws DataSetException-*/ {
    throwException(BAD_QUERY_PROPERTIES, Res.bundle.getString(ResIndex.BadQueryProperties));
  }

  /**
   * Creates and throws a DataSetException of {@link #NOT_SELECT_QUERY}.
   */
  public static final void     notSelectQuery() /*-throws DataSetException-*/ {
    throwException(NOT_SELECT_QUERY, Res.bundle.getString(ResIndex.NotSelectQuery));
  }

  /**
   * Creates and throws a DataSetException of {{@link #UNEXPECTED_END_OF_QUERY}.
   */
  public static final void     unexpectedEndOfQuery() /*-throws DataSetException-*/ {
    throwException(UNEXPECTED_END_OF_QUERY, Res.bundle.getString(ResIndex.UnexpectedEndOfQuery));
  }

  /**
   *  Creates and throws a DataSetException of {@link #UNKNOWN_PARAM_NAME}.
   * @param columnName
   */
  public static final void     unknownParamName(String columnName) /*-throws DataSetException-*/ {
    throwException(UNKNOWN_PARAM_NAME, Res.bundle.format( ResIndex.UnknownColumnName, columnName));
  }

  /**
   * Creates and throws a DataSetException of {@link #MISMATCHED_PARAMETER_FORMAT}.
   */
  public static final void     mismatchedParameterFormat() /*-throws DataSetException-*/ {
    throwException(MISMATCHED_PARAMETER_FORMAT, Res.bundle.getString(ResIndex.MismatchedParameterFormat));
  }

  /**
   * Creates and throws a DataSetException of {@link #PARAMETER_COUNT_MISMATCH}.
   *
   * @param paramCount
   * @param paramRowCount
   * @param paramMasterCount
   */
  public static final void     parameterCountMismatch(int paramCount, int paramRowCount, int paramMasterCount) /*-throws DataSetException-*/ {
    throwException(PARAMETER_COUNT_MISMATCH, Res.bundle.format(ResIndex.ParameterCountMismatch, Integer.toString(paramCount), Integer.toString(paramRowCount), Integer.toString(paramMasterCount)));
  }
  static final void     cantFindTableName() /*-throws DataSetException-*/ {
    throwException(CANNOT_FIND_TABLE_NAME, Res.bundle.getString(ResIndex.CantFindTableName));
  }

  /**
   * Creates and throws a DataSetException of {@link #NO_UPDATABLE_COLUMNS}.
   */
  public static final void     noUpdatableColumns() /*-throws DataSetException-*/ {
    throwException(NO_UPDATABLE_COLUMNS,  Res.bundle.getString(ResIndex.NoUpdatableColumns));
  }
  static final void     cantImportNullDataSet() /*-throws DataSetException-*/ {
    throwException(CANNOT_IMPORT_NULL_DATASET, Res.bundle.getString(ResIndex.CantImportNullDataSet));
  }

  /**
   *  Creates and throws a DataSetException of {@link #UNKNOWN_COLUMN_NAME}.
   *
   * @param columnName
   */
  public static final void     unknownColumnName(String columnName) /*-throws DataSetException-*/ {
    throwException(UNKNOWN_COLUMN_NAME, Res.bundle.format( ResIndex.UnknownColumnName, columnName) );
  }
  static final void     columnTypeConflict() /*-throws DataSetException-*/ {
    throwException(COLUMN_TYPE_CONFLICT, Res.bundle.getString(ResIndex.ColumnTypeConflict));
  }
  static final void     invalidColumnPosition() /*-throws DataSetException-*/ {
    throwException(INVALID_COLUMN_POSITION, Res.bundle.getString(ResIndex.InvalidColumnPosition));
  }
//! static final void     columnNotMember() /*-throws DataSetException-*/ {
//!   throwException(COLUMN_NOT_MEMBER, Res.bundle.getString(ResIndex.ColumnNotMember));
//! }
  static final void     cannotChangeColumnDataType() /*-throws DataSetException-*/ {
    throwException(CANNOT_CHANGE_COLUMN_DATA_TYPE, Res.bundle.getString(ResIndex.CannotChangeColumnDataType));
  }
  static final void     setCalculatedFailure() /*-throws DataSetException-*/ {
    throwException(SET_CALCULATED_FAILURE, Res.bundle.getString(ResIndex.SetCalculatedFailure));
  }

  /**
   *  Creates and throws a DataSetException of {@link #UNRECOGNIZED_DATA_TYPE}.
   */
  public static final void     unrecognizedDataType() /*-throws DataSetException-*/ {
    throwException(UNRECOGNIZED_DATA_TYPE, Res.bundle.getString(ResIndex.UnrecognizedDataType));
  }
//!  /*
//!  static final void     throwTooManyRows() /*-throws DataSetException-*/ {
//!    throwException(TOO_MANY_ROWS, Res.bundle.getString(ResIndex.TooManyRows));
//!  }
//!  */

/**
 *  Creates and throws a DataSetException of {@link #DATASET_HAS_NO_TABLES}.
 */
  public static final void     dataSetHasNoTable() /*-throws DataSetException-*/ {
    throwException(DATASET_HAS_NO_TABLES, Res.bundle.getString(ResIndex.DataSetHasNoTable));
  }
  static final void     columnNotInRow(String message) /*-throws DataSetException-*/ { throwException(COLUMN_NOT_IN_ROW,  message); }
  static final void     throwEmptyColumnNames() /*-throws DataSetException-*/ {
    throwException(EMPTY_COLUMN_NAMES, Res.bundle.getString(ResIndex.EmptyColumnNames));
  }
  static final void     noNonBlobColumns() /*-throws DataSetException-*/ {
    throwException(NO_NON_BLOB_COLUMNS, Res.bundle.getString(ResIndex.NoNonBlobColumns));
  }

  /**
   * Creates and throws DataSetException of {@link #TRANSACTION_ISOLATION_LEVEL_NOT_SUPPORTED}.
   */
  public static final void     transactionIsolationLevelNotSupported() /*-throws DataSetException-*/ {
    throwException(TRANSACTION_ISOLATION_LEVEL_NOT_SUPPORTED, Res.bundle.getString(ResIndex.TransactionIsolationLevelNotSupported));
  }
  static final void     partialSearchForString() /*-throws DataSetException-*/ {
    throwException(PARTIAL_SEARCH_FOR_STRING, Res.bundle.getString(ResIndex.PartialSearchForString));
  }
  static final void     needLocateStartOption() /*-throws DataSetException-*/ {
    throwException(NEED_LOCATE_START_OPTION, Res.bundle.getString(ResIndex.NeedLocateStartOption));
  }
//!  /*
//!  public static final void queryNotExecuted() /*-throws DataSetException-*/ {
//!    throwException(QUERY_NOT_EXECUTED, Res.bundle.getString(ResIndex.QueryNotExecuted));
//!  }
//!  */

/**
 * Creates and throws DataSetException of {@link #QUERY_IN_PROCESS}.
 */
  public static final void     queryInProcess() /*-throws DataSetException-*/ {
    throwException(QUERY_IN_PROCESS, Res.bundle.getString(ResIndex.QueryInProcess));
  }
  static final void     restructureInProgress(String name) /*-throws DataSetException-*/ {
    throwException(RESTRUCTURE_IN_PROGRESS, Res.bundle.format(ResIndex.RestructureInProgress, name));
  }
  static final void     throwAlreadyLoading() /*-throws DataSetException-*/ {
    throwException(ALREADY_LOADING, Res.bundle.getString(ResIndex.AlreadyLoading));
  }
  static final void     throwLoadingNotStarted() /*-throws DataSetException-*/ {
    throwException(LOADING_NOT_STARTED, Res.bundle.getString(ResIndex.LoadingNotStarted));
  }
  static final void     cannotUpdateScopedDataRow() /*-throws DataSetException-*/ {
    throwException(CANNOT_UPDATE_SCOPED_DATA_ROW, Res.bundle.getString(ResIndex.CannotUpdateScopedDataRow));
  }
  static final void     incompatibleDataRow() /*-throws DataSetException-*/ {
    throwException(INCOMPATIBLE_DATA_ROW, Res.bundle.getString(ResIndex.IncompatibleDataRow));
  }
  static final void     invalidDataFileFormat() /*-throws DataSetException-*/ {
    throwException(INVALID_DATA_FILE_FORMAT, Res.bundle.getString(ResIndex.InvalidDataFileFormat));
  }
  static final void     throwLinkColumnsError() /*-throws DataSetException-*/ {
    throwException(LINK_COLUMNS_ERROR, Res.bundle.getString(ResIndex.LinkColumnsError));
  }
  static final void     masterDetailViewError() /*-throws DataSetException-*/ {
    throwException(MASTER_DETAIL_VIEW_ERROR, Res.bundle.getString(ResIndex.MasterDetailViewError));
  }
//! static final void     invalidDetailDataSetOpen() /*-throws DataSetException-*/ {
//!   throwException(INVALID_DETAIL_DATASET_OPEN, Res.bundle.getString(ResIndex.InvalidDetailDataSetOpen));
//! }
  static final void     duplicateColumnName() /*-throws DataSetException-*/ {
    throwException(DUPLICATE_COLUMN_NAME, Res.bundle.getString(ResIndex.DuplicateColumnName));
  }
  static final void     notUpdatable() /*-throws DataSetException-*/ {
    throwException(NOT_UPDATEABLE, Res.bundle.getString(ResIndex.NotUpdatable));
  }
  static final void     resolveInProgress() /*-throws DataSetException-*/ {
    throwException(RESOLVE_IN_PROGRESS, Res.bundle.getString(ResIndex.ResolveInProgress));
  }

  /**
   * Creates and throws a DataSetException of {@link #NO_ROWS_AFFECTED}.
   *
   * @param message
   */
  public static final void     noRowsAffected(String message) /*-throws DataSetException-*/ { throwException(NO_ROWS_AFFECTED, Res.bundle.getString(ResIndex.NoRowsAffected) + message); }

  /**
   * Creates and throws a DataSetException of {@link #MULTIPLE_ROWS_AFFECTED}.
   *
   * @param message
   */
  public static final void     multipleRowsAffected(String message) /*-throws DataSetException-*/ { throwException(MULTIPLE_ROWS_AFFECTED, Res.bundle.getString(ResIndex.MultipleRowsAffected) + message); }
  static final void     dataSetOpen() /*-throws DataSetException-*/ {
    throwException(DATASET_OPEN, Res.bundle.getString(ResIndex.DataSetOpen));
  }

  /**
   * Creates and throws a DataSetException of {@link #DATASET_NOT_OPEN}.
   */
  public static final void     dataSetNotOpen() /*-throws DataSetException-*/ {
    DiagnosticJLimo.printStackTrace();
    throwException(DATASET_NOT_OPEN, Res.bundle.getString(ResIndex.DataSetNotOpen));
  }
  static final void     dataSetCorrupt(String name) /*-throws DataSetException-*/ {
    throwException(DATASET_CORRUPT, Res.bundle.format(ResIndex.DataSetCorrupt, name));
  }
  static final void     noCalcFields() /*-throws DataSetException-*/ {
    throwException(NO_CALC_FIELDS, Res.bundle.getString(ResIndex.NoCalcFields));
  }
  static final void     noCalcAggFields() /*-throws DataSetException-*/ {
    throwException(NO_CALC_AGG_FIELDS, Res.bundle.getString(ResIndex.NoCalcAggFields));
  }

  /**
   * Creates and throws a DataSetException of CONNECTION_DESCRIPTOR_NOT_SET
   * when the connection properties associated with connecting to a Database
   * are not set. These properties are stored in the ConnectionDescriptor object.
   */
  public static final void     connectionDescriptorNotSet() /*-throws DataSetException-*/ {
    throwException(CONNECTION_DESCRIPTOR_NOT_SET, Res.bundle.getString(ResIndex.ConnectionDescriptorNotSet));
  }
  static final void     invalidAggDescriptor() /*-throws DataSetException-*/ {
    throwException(INVALID_AGG_DESCRIPTOR, Res.bundle.getString(ResIndex.InvalidAggDescriptor));
  }

  /**
   *  Creates and throws a DataSetException of {@link #INVALID_SORT_COLUMN}.
   */
  public static final void     notSortable() /*-throws DataSetException-*/ {
    throwException(INVALID_SORT_COLUMN, Res.bundle.getString(ResIndex.NotSortable));
  }

  /**
   * Creates and throws a DataSetException of {@link #RESOLVE_FAILED}.
   *
   * @param ex
   */
  public static final void     resolveFailed(Exception ex) /*-throws DataSetException-*/ {
    throwException(RESOLVE_FAILED, Res.bundle.getString(ResIndex.ResolveFailed), ex);
  }
  static final void     missingResolver() /*-throws DataSetException-*/ {
    throwException(MISSING_RESOLVER, Res.bundle.getString(ResIndex.MissingResolver));
  }

  /**
   * Creates and throws a DataSetException of {@link #NOT_DATABASE_RESOLVER}.
   */
  public static final void     notDatabaseResolver() /*-throws DataSetException-*/ {
    throwException(NOT_DATABASE_RESOLVER, Res.bundle.getString(ResIndex.NotDatabaseResolver));
  }

  /**
   * Creates and throws a DataSetException of {@link #MISSING_MASTER_DATASET}.
   */
  public static final void     missingMasterDataSet() /*-throws DataSetException-*/ {
    throwException(MISSING_MASTER_DATASET, Res.bundle.getString(ResIndex.MissingMasterDataSet));
  }

  /**
   *  Creates and throws a DataSetException of {@link #NO_RESULT_SET}.
   */
  public static final void     noResultSet() /*-throws DataSetException-*/ {
    throwException(NO_RESULT_SET, Res.bundle.getString(ResIndex.NoResultSet));
  }

  /**
   * Creates and throws a DataSetException of {@link #INVALID_COLUMN_TYPE}.
   * @param column
   */
  public static final void     invalidColumnType(Column column)
   /*-throws DataSetException-*/
  {
    throwException( INVALID_COLUMN_TYPE,
                    Res.bundle.format( ResIndex.InvalidColumnType,
                    new String[] { Variant.typeName(column.getDataType()), column.getColumnName() } )
                  );
  }

  /**
   *  Creates and throws a DataSetException of {@link #INVALID_COLUMN_TYPE}.
   * @param sqlType
   */
  public static final void     invalidSQLType(int sqlType)
    /*-throws DataSetException-*/
  {
    throwException( INVALID_COLUMN_TYPE,
                    Res.bundle.format( ResIndex.InvalidColumnType,  new String[] { Integer.toString(sqlType) })
                  );
  }
  static final void     nullColumnName()
   /*-throws DataSetException-*/
  {
    throwException(NULL_COLUMN_NAME, Res.bundle.getString(ResIndex.NullColumnName));
  }

  /**
   *  Creates and throws a DataSetException of {@link #SQL_ERROR}.
   *
   * @param ex
   */
  static public final void     SQLException(SQLException ex) /*-throws DataSetException-*/ {
    throwException(SQL_ERROR, ex);
  }

  /**
   * Creates and throws an IOError exception.
   *
   * @param ex
   */
  static public final void     IOException(IOException ex) /*-throws DataSetException-*/ {
    throwException(IO_ERROR, ex);
  }
  static final void     cannotChangeColumn() /*-throws DataSetException-*/ {
    throwException(CANNOT_CHANGE_COLUMN, Res.bundle.getString(ResIndex.CannotChangeColumn));
  }

  static final void     invalidFormat(Exception ex, String columnName) /*-throws DataSetException-*/ {
    throwException(INVALID_FORMAT, Res.bundle.format(ResIndex.InvalidFormat, new String[] {columnName}), ex);
  }

/**
 * Creates and throws a DataSetException of {@link #NO_WHERE_CLAUSE}.
 *
 * @param dataSet
 */
  public static final void     noWhereClause(DataSet dataSet) /*-throws DataSetException-*/ {
    throwException(NO_WHERE_CLAUSE, Res.bundle.format(ResIndex.NoWhereClause, new String[] {dataSet.getTableName()}));
  }

  static final void     dataSetHasNoRows(DataSet dataSet) /*-throws DataSetException-*/ {
    throwException(DATASET_HAS_NO_ROWS, Res.bundle.format(ResIndex.DataSetHasNoRows, new String[] {dataSet.getTableName()}));
  }

  /**
   * Creates and throws a DataSetException of {@link #ONEPASS_INPUT_STREAM}.
   *
   * @param column
   */
  public static final void     onePassInputStream(Column column) /*-throws DataSetException-*/ {
    throwException(ONEPASS_INPUT_STREAM, Res.bundle.format(ResIndex.OnePassInputStream, new String[]{column.getColumnName()}));
  }

  /**
   * Creates and throws a DataSetException of {@link #INSUFFICIENT_ROWID}.
   */
  public static final void     insufficientRowId() /*-throws DataSetException-*/ {
    throwException(INSUFFICIENT_ROWID, Res.bundle.getString(ResIndex.InsufficientRowId));
  }

  /**
   *  Creates and throws a DataSetException of {@link #NON_EXISTENT_ROWID}.
   */
  public static final void     nonExistentRowId() /*-throws DataSetException-*/ {
    throwException(NON_EXISTENT_ROWID, Res.bundle.getString(ResIndex.NonExistentRowId));
  }

  static final void     refreshRowNotSupported() /*-throws DataSetException-*/ {
    throwException(REFRESHROW_NOT_SUPPORTED, Res.bundle.getString(ResIndex.RefreshRowNotSupported));
  }

  static final void     cannotSaveChanges(StorageDataSet dataSet) /*-throws DataSetException-*/ {
    String tableName = dataSet.getTableName();
    throwException(CANNOT_SAVE_CHANGES, Res.bundle.format(ResIndex.CannotSaveChanges, new String[]{tableName != null ? tableName : ""})); //NORES
  }

  static final void     cannotRefresh(StorageDataSet dataSet) /*-throws DataSetException-*/ {
    String tableName = dataSet.getTableName();
    throwException(CANNOT_REFRESH, Res.bundle.format(ResIndex.CannotRefresh, new String[]{tableName != null ? tableName : ""})); //NORES
  }

  static final void     invalidFormat(Exception ex, int row, Column column) /*-throws DataSetException-*/ {
    throwException(INVALID_FORMAT, Res.bundle.format(ResIndex.InvalidFormatException, new String[]{Integer.toString(row), column.getColumnName()}), ex);
  }

  static final void     columnAlreadyBound(DataSet dataSet, Column column) /*-throws DataSetException-*/ {
    throwException(COLUMN_ALREADY_BOUND, Res.bundle.format(ResIndex.ColumnAlreadyBound, column.getColumnName(), dataSet.getTableName()));
  }

  /**
   * Creates and throws a DataSetException of {@link #CONNECTION_NOT_CLOSED}.
   * @param ex
   */
  public static final void     connectionNotClosed(Exception ex) /*-throws DataSetException-*/ {
    throwException(CONNECTION_NOT_CLOSED, Res.bundle.getString(ResIndex.ConnectionNotClosed), ex);
  }
  static final void     fieldPostError(Exception ex) /*-throws DataSetException-*/ {
    throwException(FIELD_POST_ERROR, Res.bundle.getString(ResIndex.FieldPostError), ex);
  }

  /**
   *  Creates and throws a DataSetException of {@link #DRIVER_NOT_LOADED_IN_DESIGN}.
   * @param driver
   */
  public static final void     driverNotLoadedInDesign(String driver)
      /*-throws DataSetException-*/
  {
      throwException(DRIVER_NOT_LOADED_IN_DESIGN, Res.bundle.format(ResIndex.DriverNotLoadedInDesign, driver));
  }

  /**
   *  Creates and throws a DataSetException of {@link #DRIVER_NOT_LOADED_AT_RUNTIME}.
   * @param driver
   */
  public static final void     driverNotLoadedAtRuntime(String driver)
      /*-throws DataSetException-*/
  {
      throwException(DRIVER_NOT_LOADED_AT_RUNTIME, Res.bundle.format(ResIndex.DriverNotLoadedAtRuntime, driver));
  }

  /**
   * Creates and throws a DataSetException of {@link #URL_NOT_FOUND}.
   *
   * @param url
   * @param ex
   * @return
   */
  public static final DataSetException mkUrlNotFound(String url, Exception ex)
  {
    return new DataSetException(URL_NOT_FOUND, Res.bundle.format(ResIndex.UrlNotFound, url), ex);
  }

  /**
   * Creates and throws a DataSetException of {@link #URL_NOT_FOUND_IN_DESIGN}
   *
   * @param url
   * @param ex
   * @return
   */
  public static final DataSetException mkUrlNotFoundInDesign(String url, Exception ex)
  {
    return new DataSetException(URL_NOT_FOUND_IN_DESIGN, Res.bundle.format(ResIndex.UrlNotFoundInDesign, url), ex);
  }

  /**
   * Creates and throws a DataSetException of {@link #QUERY_FAILED}.
   *
   * @param ex
   */
  public static final void     queryFailed(Exception ex) /*-throws DataSetException-*/
  {
    throwException(QUERY_FAILED, Res.bundle.getString(ResIndex.QueryFailed), ex);
  }

  /**
   * Creates and throws a DataSetException of {@link #PROCEDURE_FAILED}.
   *
   * @param ex
   */
  public static final void     procedureFailed(Exception ex) /*-throws DataSetException-*/
  {
    throwException(PROCEDURE_FAILED, Res.bundle.getString(ResIndex.ProcedureFailed), ex);
  }

  /**
   * Creates and throws a DataSetException of {@link #PROVIDER_FAILED}.
   *
   * @param ex
   */
  public static final void     providerFailed(Exception ex) /*-throws DataSetException-*/
  {
    throwException(PROVIDER_FAILED, Res.bundle.getString(ResIndex.ProviderFailed), ex);
  }

  /**
   *  Creates and throws a DataSetException of {@link #PROVIDER_OWNED}.
   *
   * @return
   */
  public static final DataSetException providerOwned()
  {
    return new DataSetException(PROVIDER_OWNED, Res.bundle.getString(ResIndex.ProviderOwned));
  }

  /**
   * Creates and throws a DataSetException of BAD_PROCEDURE_PROPERTIES when
   * one or more properties of the ProcedureDescriptor are invalid.
   */
  public static final void badProcedureProperties() /*-throws DataSetException-*/ {
    throwException(BAD_PROCEDURE_PROPERTIES, Res.bundle.getString(ResIndex.BadProcedureProperties));
  }

  static final void needStorageDataSetForFetchAsNeeded() /*-throws DataSetException-*/ {
    throwException(NEED_STORAGEDATASET, Res.bundle.getString(ResIndex.NeedStorageDataSet));
  }

  /**
   *  Creates and throws DataSetException of {@link #WRONG_DATABASE}.
   */
  public static final void wrongDatabase() /*-throws DataSetException-*/ {
    throwException(WRONG_DATABASE, Res.bundle.getString(ResIndex.WrongDatabase));
  }

  /**
   * Creates and throws a DataSetException of {@link #MISMATCH_PARAM_RESULT}.
   */
  public static final void mismatchParamResult() /*-throws DataSetException-*/ {
    throwException(MISMATCH_PARAM_RESULT, Res.bundle.getString(ResIndex.MismatchParamResult));
  }

  /**
   * Creates and throws a DataSetException of {@link #PROCEDURE_IN_PROCESS}.
   */
  public static final void procedureInProcess() /*-throws DataSetException-*/ {
    throwException(PROCEDURE_IN_PROCESS, Res.bundle.getString(ResIndex.ProcedureInProcess));
  }

  /**
   * Creates and throws a DataSetException of {@link #NEED_QUERYPROVIDER}.
   */
  public static final void needQueryProvider() /*-throws DataSetException-*/ {
    throwException(NEED_QUERYPROVIDER, Res.bundle.getString(ResIndex.NeedQueryProvider));
  }

  /**
   *  Creates and throws a DataSetException of {@link #NEED_PROCEDUREPROVIDER}.
   */
  public static final void needProcedureProvider() /*-throws DataSetException-*/ {
    throwException(NEED_PROCEDUREPROVIDER, Res.bundle.getString(ResIndex.NeedProcedureProvider));
  }

  /**
   * Creates and throws a DataSetException of {@link #NO_DATABASE_TO_RESOLVE}.
   */
  public static final void noDatabaseOnResolver() /*-throws DataSetException-*/ {
    throwException(NO_DATABASE_TO_RESOLVE, Res.bundle.getString(ResIndex.NoDatabaseOnResolver));
  }

  /**
   * Creates and throws a DataSetException of {@link #UNKNOWN_DETAIL_NAME}.
   * @param detailName
   */
  public static final void     unknownDetailName(String detailName) /*-throws DataSetException-*/ {
    throwException(UNKNOWN_DETAIL_NAME, Res.bundle.format( ResIndex.UnknownDetailName, detailName) );
  }

  /**
   * Creates and throws a DataSetException of {@link #CLASS_NOT_FOUND_ERROR}.
   * @param ex
   */
  public static final void     classNotFoundException(ClassNotFoundException ex) /*-throws DataSetException-*/ {
    throwException(CLASS_NOT_FOUND_ERROR, ex);
  }
  static final void     noOriginalRow() /*-throws DataSetException-*/ {
    throwException(NO_PRIOR_ORIGINAL_ROW, Res.bundle.getString(ResIndex.NoOriginalRow));
  }

  /**
   * Creates and throws a DataSetException of {@link #READ_ONLY_STORE}.
   *
   * @param dataSetName
   */
  public static final void     readOnlyStore(String dataSetName) /*-throws DataSetException-*/ {
    throwException(READ_ONLY_STORE, Res.bundle.format( ResIndex.ReadOnlyStore, dataSetName) );
  }
  static final void     missingReplaceRow() /*-throws DataSetException-*/ {
    throwException(MISSING_REPLACESTOREROW, Res.bundle.getString(ResIndex.MissingReplaceRow));
  }

  /**
   * Creates and throws a DataSetException of {@link #INVALID_STORE_NAME} when the
   * value of the storeName property is blank.
   *
   * @param name
   */
  public static final void     invalidStoreName(String name) /*-throws DataSetException-*/ { throwException(INVALID_STORE_NAME, Res.bundle.format(ResIndex.InvalidStoreName, name));}

  /**
   * Creates and throws a DataSetException of {@link #DELETE_DUPLICATES}.
   */
  public static final void     deleteDuplicates() /*-throws DataSetException-*/ { throwException(DELETE_DUPLICATES, Res.bundle.getString(ResIndex.DeleteDuplicates));}

  /**
   * Creates and throws a DataSetException of {@link #INVALID_CLASS}.
   * @param javaClass
   */
  public static final void     invalidClass(Class javaClass) /*-throws DataSetException-*/ { throwException(INVALID_CLASS, Res.bundle.format(ResIndex.DeleteDuplicates, javaClass.getName()));}

  /**
   * Creates and throws a DataSetException of {@link #NEEDS_RECALC}.
   * @param storeName
   */
  public static final void     needsRecalc(String storeName) /*-throws DataSetException-*/ { throwException(NEEDS_RECALC, Res.bundle.format(ResIndex.NeedsRecalc, storeName));}

  /**
   * Creates and throws a DataSetException of {@link #INVALID_CLASS}
   *
   * @param storeClassName
   * @param className
   */
  public static final void invalidClass(String storeClassName, String className) /*-throws DataSetException-*/ {
    throwException(INVALID_STORE_CLASS, Res.bundle.format(ResIndex.InvalidStoreClass, storeClassName, className));
  }

  static final void invalidIteratorUse() /*-throws DataSetException-*/ {
    throwException(INVALID_ITERATOR_USE, Res.bundle.getString(ResIndex.InvalidIteratorUse));
  }

  static final void duplicatePrimary() /*-throws DataSetException-*/ {
    throwException(DUPLICATE_PRIMARY, Res.bundle.getString(ResIndex.DuplicatePrimary));
  }

  static final void noPrimaryKey() /*-throws DataSetException-*/ {
    throwException(DUPLICATE_PRIMARY, Res.bundle.getString(ResIndex.NoPrimaryKey));
  }

  static final void invalidSortAsInserted() /*-throws DataSetException-*/ {
    throwException(INVALID_SORT_AS_INSERTED, Res.bundle.getString(ResIndex.InvalidSortAsInserted));
  }

  static final void invalidSort(String name) /*-throws DataSetException-*/ {
    throwException(INVALID_SORT, Res.bundle.format(ResIndex.InvalidSort, name));
  }

  static final void invalidConstraintName(String name) /*-throws DataSetException-*/ {
    throwException(INVALID_CONSTRAINT_NAME, Res.bundle.format(ResIndex.ConstraintMissing, name));
  }

  public static final void tooManyAutoInc(Column col1, Column col2) /*-throws DataSetException-*/ {
    throwException(TOO_MANY_AUTO_INCREMENTS, Res.bundle.format(ResIndex.TooManyAutoInc, col1.getColumnName(), col2.getColumnName()));
  }

  // Cannot resource for 6.01 patch.  Must resource for next release.
  //
  static final void dependentForeignKey(String name1, String name2) /*-throws DataSetException-*/ {
    throwException(INVALID_CONSTRAINT_NAME, Res.bundle.format(ResIndex.InvalidConstraintName, new Object[] {name1, name2}));
  }

}

